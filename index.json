[{"content":"Abstract Recently I came across a simple palindrome problem. Which inputs an integer number and check if it\u0026rsquo;s a palindrome. In case you don\u0026rsquo;t know, palindrome sequence of characters or number which reads the same backward as forward.\nThe Palindrome Algorithms. These are very basic and simple problems to solve. And most of the time\u0026rsquo;s people tend to use an array, string, list, or any data structure of a similar manner to store data. I had solved loads of palindrome problems in past. The main algorithm is to split the data in half, then reverse check. bingo !!! you\u0026rsquo;re done. But I was skeptical if the same can be done without using any data structure. The benefit of ditching data structures. I was optimistic if I can slice and reverse a piece of number, which is technically a data structure niche. Maybe i can optimize this palindrome algorithm to a whole new level. Since using and iterating through unsorted data structure is a resource-consuming task that rises with the amount of data linearly or sometimes exponentially depending on related factors.\nSo my journey toward excellence begins. Soon and pretty simple enough I found the first piece of grail. Before I can quantitively slice anything. I need to find the size of that entity. and for integer, it\u0026rsquo;s simple math equitation.\nFind the size of an integer. f ( n ) = \u0026#x230A;  log 10   \u0026#x2061; ( n ) + 1 \u0026#x230B;  See! pretty simple you just need to log a number with a 10 base logarithmic function. then add 1 and voila!!\n#include \u0026lt;math.h\u0026gt;int sizeof_int(int* n){ return (int)floor(log10(*n) + 1); } You just calculate the size of an integer without a loop or any recursive operation. and its time complexity is O(1).\nSlicing integer. Since we calculate the size of an integer, now we can slice them in two with a division and modulus operation. Just like we did in MSD and LSD Calculation.\nint integerSlicer(int *number, int *first_part, int *second_part) { //size of this number.  int sizeof_number = sizeof_int(number); //trimming for odd number :)  int range = sizeof_number - sizeof_number % 2; *first_part = floor(*number / pow(10, sizeof_number - (range / 2))); *second_part = *number % (int)pow(10, range / 2); return 0; } now its time complexity is O(1). Though the Modulus operator is a bit slower. But it\u0026rsquo;s insignificant.\nInteger reversing Up until now, We perform some critical operations with peerless efficiency. And avoid iteration, repetition as much as possible. But Decimal Reversing is a process where each element has to be picked individually and place at its significant figure subsequently.\nFirst, we have to take an empty integer variable assigned to zero for storing. Then we will slice the Most significant digit and add them to the new variable according to its significant figure.\nint digit_reverser(int digit, int size_of_digit) { if (size_of_digit \u0026lt;= 1) return digit; int local_significant_position = floor(pow(10, size_of_digit - 1)); int data = floor(digit % 10) * local_significant_position; return data + digit_reverser(floor(digit / 10), (size_of_digit - 1)); } Visually speaking:\nThis particular function\u0026rsquo;s time complexity is O(log n). it is the bottleneck of the entire program. Now, all we have to do is check the other part if those are equal.\nEnd This concludes the article.\nSince we have all the necessary elements to complete this program. First, try to complete this code on your own.\nAnd Check hereafter\nYou Can try some problems with your newly gained knowledge.\n","permalink":"https://jony-blog.github.io/posts/efficient_palindrome_int_slicing/","summary":"Abstract Recently I came across a simple palindrome problem. Which inputs an integer number and check if it\u0026rsquo;s a palindrome. In case you don\u0026rsquo;t know, palindrome sequence of characters or number which reads the same backward as forward.\nThe Palindrome Algorithms. These are very basic and simple problems to solve. And most of the time\u0026rsquo;s people tend to use an array, string, list, or any data structure of a similar manner to store data.","title":"Efficient Palindrome and Integer Slicing."},{"content":"{ \"@context\": \"http://www.schema.org\", \"@type\": \"person\", \"image\": \"\", \"name\": \"Sohel Ahmed Jony\", \"jobTitle\": \"Computer Scientist\", \"url\": \"https://jony-blog.github.io\", \"address\": { \"@type\": \"PostalAddress\", \"streetAddress\": \"mirpur, Dhaka\", \"addressLocality\": \"dhaka\", \"addressRegion\": \"dhaka\", \"postalCode\": \"1216\", \"addressCountry\": \"Bangladesh\" }, \"email\": \"sohelahmedjony@gmail.com\" }  ","permalink":"https://jony-blog.github.io/aboutme/","summary":"{ \"@context\": \"http://www.schema.org\", \"@type\": \"person\", \"image\": \"\", \"name\": \"Sohel Ahmed Jony\", \"jobTitle\": \"Computer Scientist\", \"url\": \"https://jony-blog.github.io\", \"address\": { \"@type\": \"PostalAddress\", \"streetAddress\": \"mirpur, Dhaka\", \"addressLocality\": \"dhaka\", \"addressRegion\": \"dhaka\", \"postalCode\": \"1216\", \"addressCountry\": \"Bangladesh\" }, \"email\": \"sohelahmedjony@gmail.com\" }  ","title":"About me"}]